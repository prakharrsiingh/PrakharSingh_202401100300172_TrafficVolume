# -*- coding: utf-8 -*-
"""PrakharSingh.202401100300172

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SPc9afC2xehqAzV8Awm5BHzpykZtKmKT
"""

# --- Imports ---
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

# Scikit-learn imports for preprocessing, modeling, evaluation
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression, Ridge, Lasso
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer

# --- Load Data ---
df = pd.read_csv("/content/Metro_Interstate_Traffic_Volume.csv")  # Load dataset

# --- Feature Engineering ---
df['date_time'] = pd.to_datetime(df['date_time'])         # Convert to datetime
df['hour'] = df['date_time'].dt.hour                      # Extract hour
df['dayofweek'] = df['date_time'].dt.dayofweek            # Extract weekday (0=Mon, 6=Sun)
df['month'] = df['date_time'].dt.month                    # Extract month
df['year'] = df['date_time'].dt.year                      # Extract year
df['is_weekend'] = df['dayofweek'].isin([5, 6]).astype(int)  # Boolean feature for weekend

# Drop unused columns
df = df.drop(columns=['date_time', 'weather_description'])

# --- Separate Features & Target ---
X = df.drop(columns=['traffic_volume'])  # Features
y = df['traffic_volume']                 # Target variable

# --- Column Categories for Preprocessing ---
categorical_features = ['holiday', 'weather_main']  # Categorical columns
numerical_features = [col for col in X.columns if col not in categorical_features]  # All others are numerical

# --- Preprocessing Pipeline ---
preprocessor = ColumnTransformer(
    transformers=[
        # Pipeline for numeric columns: handle missing values + scale
        ('num', Pipeline(steps=[
            ('imputer', SimpleImputer(strategy='median')),
            ('scaler', StandardScaler())
        ]), numerical_features),

        # Pipeline for categorical columns: fill missing + encode
        ('cat', Pipeline(steps=[
            ('imputer', SimpleImputer(strategy='most_frequent')),
            ('encoder', OneHotEncoder(handle_unknown='ignore'))
        ]), categorical_features)
    ]  # <--- Make sure this closing bracket matches 'transformers=['
)

# --- Model Pipeline (Linear Regression as base model) ---
lr_pipeline = Pipeline([
    ('preprocessor', preprocessor),         # First step: preprocessing
    ('regressor', LinearRegression())       # Second step: regression
])

# --- Train/Test Split ---
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# --- Train the Model ---
lr_pipeline.fit(X_train, y_train)
y_pred = lr_pipeline.predict(X_test)  # Predict on test set

# --- Evaluation Function ---
def evaluate_model(y_true, y_pred, model_name="Model"):
    mse = mean_squared_error(y_true, y_pred)      # Mean Squared Error
    r2 = r2_score(y_true, y_pred)                 # R-squared Score
    print(f"{model_name}:\n  - MSE: {mse:.2f}\n  - RÂ²: {r2:.4f}")

# Evaluate Linear Regression
evaluate_model(y_test, y_pred, "Linear Regression")

# --- Try Other Regressors for Comparison ---
for name, regressor in [
    ("Ridge", Ridge(alpha=1.0)),                          # Ridge Regression
    ("Lasso", Lasso(alpha=0.1)),                          # Lasso Regression
    ("Random Forest", RandomForestRegressor(n_estimators=100, random_state=42))  # Tree-based model
]:
    pipeline = Pipeline([
        ('preprocessor', preprocessor),
        ('regressor', regressor)
    ])
    pipeline.fit(X_train, y_train)
    preds = pipeline.predict(X_test)
    evaluate_model(y_test, preds, name)

# --- Visualizations ---

# 1. Distribution of target variable
plt.figure(figsize=(10, 5))
sns.histplot(y, bins=50, kde=True, color='skyblue')
plt.title('Distribution of Traffic Volume')
plt.xlabel('Traffic Volume')
plt.ylabel('Frequency')
plt.grid(True)
plt.show()

# 2. Traffic volume by hour (to spot rush hours)
plt.figure(figsize=(12, 6))
sns.boxplot(x='hour', y='traffic_volume', data=df, palette='coolwarm')
plt.title('Traffic Volume by Hour of Day')
plt.xlabel('Hour of Day')
plt.ylabel('Traffic Volume')
plt.grid(True)
plt.show()

# 3. Volume by weekday to spot weekly patterns
plt.figure(figsize=(10, 5))
sns.boxplot(x='dayofweek', y='traffic_volume', data=df)
plt.title('Traffic Volume by Day of Week')
plt.xlabel('Day of Week (0=Mon, 6=Sun)')
plt.ylabel('Traffic Volume')
plt.grid(True)
plt.show()

# 4. Actual vs Predicted for performance visualization
plt.figure(figsize=(10, 5))
sns.scatterplot(x=y_test, y=y_pred, alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')  # Ideal line
plt.title('Actual vs Predicted Traffic Volume')
plt.xlabel('Actual Traffic Volume')
plt.ylabel('Predicted Traffic Volume')
plt.grid(True)
plt.show()